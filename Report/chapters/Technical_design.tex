%Het technisch ontwerp wordt geschreven voor de collega die aan het project zal verder werken als jij dat niet meer doet, jouw opvolger dus.
%Algemene richtlijnen Bachelorproef 2014-2015 p. 7
%Het is uiterst gedetailleerd en bevat ook hints en waarschuwingen voor pistes die niet nuttig bleken.
%In het technisch ontwerp worden niet alleen de programma's en bestands- en geheugenlay-out uitvoerig gedocumenteerd maar ook worden het elektronisch schema en de lay-out uitgebreid uitgelegd. De testen van de hardware en de software worden grondig besproken.
%Het technisch ontwerp gaat in op de keuze van schakelingen en componenten, het mechanisch ontwerp en de beschrijving van de PCB’s.
%De gedetailleerde beschrijving van de user interface en de gegevensopslag vormt de basis van het grootste deel van het software-ontwerp. Bij groot gegevensgebruik wordt zeker ingegaan op de organisatie in bestanden en gegevensbanken en hierbij wordt gebruikgemaakt van het datamodel uit de functionele analyse.
%Van de programma’s wordt per deel besproken welke variabelen aan de ingang liggen, welke gegevens worden doorgegeven en welke gegevens eventueel worden afgedrukt op een scherm of op een user interface.
%Er zal worden beschreven wat het programma met de gegevens doet. Daarbij zullen de algoritmes worden geïmplementeerd die in de functionele analyse werden gepresenteerd.
%Indien er verschillende talen worden gebruikt, is een praktische beschrijving van de interface tussen de talen belangrijk.
%De verschillende schakelingen worden - indien mogelijk - gesimuleerd en pas daarna worden de schakelingen op de PCB’s ontworpen.
%In het technisch ontwerp worden vaak ook opgenomen: de gebruikershandleiding, de problemen, de oplossingen en de testresultaten. In sommige ontwerpen zijn die testresultaten vaak het belangrijkste aspect.
%De technische beschrijving moet er vooral voor zorgen dat iemand die verder werkt aan dit project zo weinig mogelijk moeilijkheden ondervindt om dit te doen. De technische beschrijving moet vooral volledig zijn en gedetailleerd.

\chapter{Technical design} \label{TD}
\section{Testbench creation}
This chapter holds a step by step description of the development of the software. Every new element is introduced by means of increasingly complicated example source files.
\subsection{Simple example}
\subsubsection{The WaveDrom file}
Although the primary goal of this product is to create testbenches for timed designs, a basic first draft of the tool's conversion script can be created based on a simple combinatorial design.
\npar
The example this draft was based on was an AND-gate design. The AND-gate design can be found in appendix \ref{appendix:andgate:combinatorial}. All designs used in this project can be found online \cite{examples} in each example's respective design directory (vhdl\_files/src).
\npar
A WaveDrom file for describing the wave traces of a purely combinatorial AND-gate is shown in code \ref{json:simple_example}.
\begin{lstlisting}[style=json, caption={Standard WaveDrom description for a combinatorial AND-gate}, label={json:simple_example}]
{"signal": [
	{"name":"A", "wave":"0"},
	{"name":"B", "wave":"0"},
	{"name":"F", "wave":"0"}]  
}
\end{lstlisting}\noindent
Where A and B are considered input signals and F is the output signal. This yields the following wave trace image, which shows that F should be low when both inputs are also low.%
\MijnFig{width=.2\textwidth}{images/comb_and0}{Wave traces corresponding to description in code \ref{json:simple_example}}{fig:comb_and0}
\nline
This is neither very clear, nor does it hold enough information on its own to create a testbench.
To be able to create a testbench several more fields containing extra information should be added.
\npar
The necessities for creating a testbench are:
\begin{itemize}
	\item The exact name of the unit under test
	\item The VHDL signal type for every signal
	\item The direction of the signal (input or output)
\end{itemize}\noindent
These fields have been added to the WaveDrom file together with a name and description for this test. The new WaveDrom file is shown in code \ref{json:andgate_example_extended}:\newpage
\begin{lstlisting}[style=json, caption={Extended WaveDrom description for a combinatorial AND-gate}, label={json:andgate_example_extended}]
{"name": "andGate", "test" : "andgate00", 
"description": "Input A = '0' & B = '0' should produce a low output", 
"signal": [
	["IN",
		{"name": "A", "wave": "0", "type": "std_logic"},
		{"name": "B", "wave": "0", "type": "std_logic"}],
	["OUT",
		{"name": "F", "wave": "0", "type": "std_logic"}]
]}
\end{lstlisting}\noindent
Where "name" should be the exact name of the unit under test and the signal names have to be exactly the same as the port names in the uut design. Each port should be defined below their corresponding label of direction. All input files must be defined below the “IN” label and all output signals under the “OUT” label. Now all information needed to create a testbench is available in the source file.
\subsubsection{Creating VHDL code from the WaveDrom file}\label{TD:vhdl_creation}
The information in this file has to be translated to VHDL code. More specifically the information in the WaveDrom file should be converted into:
\begin{itemize}
	\item Signal declarations for every signal
	\item DUT declaration
	\item DUT port map
	\item Input signal stimulus
	\item Output signal checking
\end{itemize}\noindent
These are the elementary parts of a VHDL testbench. The python JSON package enables an easy conversion of information by reading all of the waveJSON information and placing it in a Python JSON container. This way, data in the Python code has the same structure as the data in the WaveDrom file. Because all the information is now available in the Python program all that has to be done is manipulate standard strings to fit the current design.
\newpage
For example the string manipulation code for signal declarations is given below. 
\begin{lstlisting}[style=python, caption={Generating signal declarations in Python}, label={python:signal_declaration}]
def generate_signal_declaration(json_signal):
	signal_name = json_signal["name"]
	signal_type = json_signal["type"]
	
	#example: "signal sig_example : std_logic :='0';
	return "signal sig_" + signal_name + " : " + \
					signal_type + " := '0';"
\end{lstlisting}\noindent
This method reads the information regarding a single JSON signal and produces a VHDL signal declaration string which initializes the signal to '0'.
\npar
In the same way signal stimuli and the UUT port map can be generated.
\begin{lstlisting}[style=python, caption={Generating signal stimuli in Python}, label={python:signal_stimuli}]
def create_stimulus(input_signals):
	stimulus = ""
	for signal in input_signals:
		if len(signal) > 0:
			value = signal["wave"]
			
			#example: "sig_example <= '1';"
			stimulus += "sig_" + signal["name"] + " <= '" + value + "';\n"
	return stimulus
\end{lstlisting}\noindent
This method needs a list of all input signals in JSON format. It creates a VHDL assignment assigning them the value contained in the “wave” field and returns that string. The result can be directly added to the testbench.\newpage
\begin{lstlisting}[style=python, caption={Generating a port map in Python}, label={
python:port_map}]
def generate_port_map(json_signal_set):
	port_map = "PORT MAP(\n"
	first = True
	for signal_type in json_signal_set:     # IN and OUT.
		if len(signal_type) > 0:            # JSON allows empty elements
			for signal in signal_type:
				if len(signal) > 0:         # JSON allows empty elements
					if first:
						#example: "example => sig_example"
						new_map = signal["name"] + " => sig_" + signal["name"]
						first = False
					else:
						new_map = ",\n" + signal["name"] + " => sig_" + signal["name"]
						port_map += new_map
	port_map += " );"
	return port_map
\end{lstlisting}\noindent
The port map is generated from a list of all signals. As in the input WaveDrom file this list is composed of two sublists: the signals defined under “IN” and those under “OUT”. These lists are iterated through and for each element that is not empty a new element is added to the port map. The final port map is returned and is ready to be added to the testbench file.
\subsubsection{Converting the WaveDrom file to a VHDL testbench}
Every testbench is structurally the same at its base. The main elements are the signal declarations, the device under test (DUT) declaration, the port mapping of the DUT, the clock driving process and the stimulus process. As the previous paragraph explains, these elements can all be generated from the WaveDrom file. All that is left to do is organize these elements in the proper structure. To do this a template is used. This template defines the structure of the testbench by placing keywords that will be recognized by the program. when creating a test, the tool will replace these keywords with design specific code. In this template the VUnit checking capabilities are integrated, allowing for conditional logging. The final version of the template can be found in appendix \ref{appendix:template}.
\newpage\noindent
The space for input and output signals is marked by the keywords '--\# Input Signals' and '--\# Output Signals' respectively. Every signal declaration is created and placed below the corresponding keyword. 
\npar
Using this method the first fully functional testbench was created that can be run using VUnit. The creation is however limited to combinatorial designs.
\subsection{Clocked designs}
The next step is to move on to Clocked (or timed) designs, which will be the main focus of this project. The design used to test this step does not differ from the previous AND-gate design except that the gate will be triggered by a clock signal. This allows the creation of more extensive tests. The AND-gate VHDL design can be found in appendix \ref{appendix:andgate:sequential}.
\npar
The WaveDrom source file for testing all possible inputs of an AND-gate is shown in code \ref{json:andgate_full}. The generated wave traces are shown in fig \ref{fig:andgate_full}.
\begin{lstlisting}[style=json, caption={JSON source file for a full AND-gate test}, label={json:andgate_full}]
{"name": "andGate_timed", "test" : "andgate_full", 
"description": "test all possible inputs for an AND-gate", 
"signal": [
	["CLK",
		{"name": "CLK", "wave": "p......", "type":"std_logic", "period":"2", "clock_period": "20"}],
	["IN",
		{"name": "A", "wave": "01010..", "type": "std_logic", "period":"2"},
		{"name": "B", "wave": "0.....1.0.1.0.", "type": "std_logic"}],
	["OUT",
		{"name": "F", "wave": "0.....1.0.....", "type": "std_logic"}]
]}
\end{lstlisting}\clearpage
\MijnFig{width=.9\textwidth}{images/andgate_full}{Wave traces generated by WaveDrom based on the source file in code \ref{json:andgate_full}}{fig:andgate_full}\noindent
The clock signal is distinguished from the other input signals by adding a new label.
\npar
Firstly, until now signal driving and checking was quite straightforward. The signals were given the value specified in the WaveDrom file and after a short wait the output was checked. In timed designs, however, ports can have different values every time the clock value changes. Because of this it is necessary to loop over the values of the signals and load a new value every clock cycle.
\npar
Secondly, the new clock signal introduces the need to implement a clock driving process and to define a clock period. 
\subsubsection{Driving and checking the signals}
The value of every input signal can change every clock cycle. This means that a new value should be loaded every clock cycle. To be able to do this inside a VHDL testbench two things are needed. First, all future values have to be known on simulation start and secondly, the current clock cycle has to be known at all times. For every signal an array will be defined that holds all values that will ever be assigned to it. The index of every element in that array corresponds to the time step at which it will be assigned, which is why the current clock cycle must always be known.
\npar
Creating these arrays requires three things. A conversion of the JSON signal value representation to a VHDL representation, knowing the logic type of the signal concerned, and knowing the length of the array.
\npar
Converting the JSON signal value boils down to expanding the "value" string and converting the separate characters (e.g. the "wave" field of a waveJSON signal of "0.1." will be converted into ('0', '0', '1', '1')). A '.' represents the repetition of a previous value.
\npar
To create an array, the logic type it holds must also be known, because an array type can only be defined if the type contained in it is known. For example, the array type for an array of length clock\_cycles containing std\_logic elements is defined as seen in code \ref{vhdl:array_type_declaration}.
\begin{lstlisting}[style=vhdl, caption={Declaration of an std\_logic array type of lenght clock\_cycles}, label={vhdl:array_type_declaration}]
type std_logic_array is array (0 to clock_cycles - 1) of std_logic;
\end{lstlisting}\noindent
This array type must be defined before an instance of it can be created. Consider the JSON input signal “sig\_example” of which the signal wave is defined as “01” that has logic type “std\_logic”. If no type exists that can hold std\_logic elements this array type is first defined as in code \ref{vhdl:array_type_declaration}. After this the actual array can be declared. The array holding the values will be named "sig\_example\_values" and its definition will look like in code \ref{vhdl:sig_example}:
\begin{lstlisting}[style=vhdl, caption={Definition of a std\_logic array}, label={vhdl:sig_example}]
constant sig_example_values : std_logic_array := ('0', '1');
\end{lstlisting}\noindent
We assume that the test is defined for two clock cycles and the clock\_cycle constant is equal to 2. This constant is derived from the amount of values in the "wave" field of a waveJSON signal and should be the same for every signal.
\npar
These arrays are not only used to store the future values for all input signals, but are also used to store expected values for output signals. Every time the input changes, the output can change too. Because the current clock cycle is known the simulated output can be compared to what is expected at this point in the simulation. This comparison is what is called a signal check and the result of the test will depend on whether the two values are equal or not.
\npar
Now all that is left to do is to assign the next value and compare the output signals every clock cycle. This is illustrated in code \ref{vhdl:driving_signals}.
\subsubsection{Clock driving}
Defining a clock driving process and clock period inside a testbench does not require a lot of effort. A new keyword was added to the testbench for both. The keywords '--\# Constants' and  '--\# Clock Driver" respectively are placeholders for the constant declaration and clock driving process respectively. 
\begin{lstlisting}[style=vhdl, caption={Definition of a std\_logic array}, label={vhdl:clock_period}]
constant internal_clock_period : time := 20.0 ns;
\end{lstlisting}\noindent
\begin{lstlisting}[style=vhdl, caption={Signal driving in clocked designs}, label={vhdl:driving_signals}]
Clk_proces : process
begin
	if (EndOfSimulation = '0') then
		internal_clock <= '1';
		wait for internal_clock_period / 2;
		internal_clock <= '0';
		wait for internal_clock - internal_clock_period / 2;
	end if;
end process;
\end{lstlisting}\noindent
The clock driving process is not design dependent and is simply added to the testbench whenever a clock signal is detected in the WaveDrom file. The clock period can be specified (in ns) in the WaveDrom file as seen in code \ref{json:andgate_full}, but will default to 20 ns if that is not the case.
\npar
Because it is unknown whether the actual clock signal will be high-to-low or low-to-high, an internal clock signal is introduced which will trigger the driving process. Every input signal, including the actual clock, will be driven on the rising edge of the internal clock and every output signal will be checked on the falling edge. The internal clock is always the same, but the actual clock can be different for every design. Figure \ref{fig:clocks} shows how the internal clock relates to some possible internal clocks.%
\MijnFig{width=.82\textwidth}{images/clocks}{Examples of actual clock signals compared to the internal clock}{fig:clocks}\nline
Actual clock signals can change twice every internal clock period (e.g. negative clock and looping clock) and have to be driven on the falling edge as well as the rising edge of the internal clock. For the timed AND-gate example the driving and checking process of the signals is shown in code \ref{vhdl:andgate_full}.
\begin{lstlisting}[style=vhdl, caption={Signal driving in the AND-gate test derived from the source file in code \ref{json:andgate_full}}, label={vhdl:andgate_full}]
while (n <= clock_cycles -1) loop
	wait until rising_edge(internal_clock);
	sig_CLK <= sig_CLK_values(2*n);		
	sig_A <= sig_A_values(n);
	sig_B <= sig_B_values(n);
	
	wait until falling_edge(internal_clock);
	-- CLK has twice as many values as other signals
	sig_CLK <= sig_CLK_values(2*n_1);	
\end{lstlisting}\noindent
This means that the amount of clock cycles should be known within the testbench. The conversion software calculates the amount of clock cycles in the WaveDrom file and adds a clock\_cycles constant to the testbench using another keyword.
\npar
This internal clock has another advantage. WaveDrom allows for signals to have a relative period. The relative period can be set for every signal separately using the "period" field. A relative period of 2 means that a signal will keep every value denoted in the "wave" field for 2 time steps. This way, for example, the actual clock can run twice as slow as the internal clock. This is illustrated in figure \ref{fig:clocks} by "double clock". This allows output signals to change on the falling edge of a high-to-low clock signal (e.g. "example signal" in relevance to "double clock"), which would not be possible if all signals were driven on the first edge of the actual clock signal. The internal clock period will define the length of a time step and will rise and fall within one time step. This way each signal is driven or checked every time step regardless of their relative period.\newpage
\section{Vectors and repetitions}
At this point it is possible to create testbenches for timed designs. To test the robustness a more complicated design is tested: the UART design example available in the VUnit documentation \cite{vunit_doc}. The UART design can be found in appendix \ref{appendix:uart}.
\subsection{Vectors}
In a first test the UART will be required to send the content of the parallel input 'data' (1 byte) over its serial output 'tx'. The scope of this first test will be limited to the first 8 clock periods, right before the actual sending of the data. The WaveDrom input code and corresponding wave traces are shown below.
\begin{lstlisting}[style=json, caption={Source file for creating the first transmission test for the UART design in \ref{appendix:uart}}, label={json:uart_no_wait}]
{"name": "uart_tx", "test" : "uart_send_1_byte_no_wait", 
"description": "Send one byte with a parallel to serial uart (actual sending excluded)", 
"signal": [
	["CLK",
		{"name": "clk", "wave": "n.......", "type":"std_logic", "period": "2", "clock_period": "20"}],
	["IN",
		{"name": "tvalid", "wave": "0.1..0..........", "type": "std_logic"},
		{"name" : "tdata", "wave": "=.=..=..........", "data": ["0", "249", "0"], "type" : "std_logic_vector", "vector_size" : "8"}],
	["OUT",
		{"name": "tx", "wave": "1....0..........", "type": "std_logic"},
		{"name": "tready", "wave": "01.0............", "type": "std_logic"}]
]}
\end{lstlisting}\noindent
\MijnFig{width=.9\textwidth}{images/uart_no_wait}{Wave traces generated by WaveDrom from code \ref{json:uart_no_wait}}{fig:uart_no_wait}\newpage\noindent
The image above also illustrates the benefit of the relative period set in the "clk" signal. Where each clock cycle would take only one internal clock cycle to complete if the "period" field were not, it will now take two. This allows the "tvalid" signal to transit from high to low halfway through a clock cycle. The "clock\_period" field will make sure every actual clock cycle will still only take 20 ns, instead of the standard 20 ns per internal clock cycle, which would total to 40 ns per actual clock cycle. 
\npar
This new design poses a new challenge , however. This is the first design that uses vectors as a port type. WaveDrom supports the use of vectors with the help of the '=' character and the 'data' field. The approach to converting the WaveDrom vector information to VHDL vector information is not very different from the approach regarding single bit ports. The only difference lies in the newly added "data" and "vector\_size" fields. The information contained in the "data" field has to be linked to the correct '=' character before converting the signal to VHDL code. This last step requires some extra information, however. In VHDL it is necessary to know the size of a vector before it can be declared. This information has to be added to the wavedrom file. The field ‘vector\_size’ holds this information.
\newpage
\subsubsection{Time loops}
The second test for the UART design is an extension of the first. This time the design will be allowed to send the data over its 'tx' output.
\begin{lstlisting}[style=json, caption={Source file for creating a second transmission test for the UART design in \ref{appendix:uart}}, label={json:uart_wait}]
{"name": "uart_tx", "test" : "uart_send_1_byte", 
"description": "Send one byte with a parallel to serial uart.", 
"signal": [
	["CLK",
		{"name": "clk", "wave": "n......|", "type":"std_logic", "period": "2", "clock_period": "20", "loop_times" : ["10*434"]}],
	["IN",
		{"name": "tvalid", "wave": "0.1..0..........", "type": "std_logic"},
		{"name" : "tdata", "wave": "=.=..=........x.", "data": ["0", "249", "0"], "type" : "std_logic_vector", "vector_size" : "8"}],
	["OUT",
		{"name": "tx", "wave": "1....0........x.", "type": "std_logic"},
		{"name": "tready", "wave": "01.0..........x.", "type": "std_logic"}]
]}
\end{lstlisting}\noindent
\MijnFig{width=.9\textwidth}{images/uart_wait}{Wave traces generated by WaveDrom from code \ref{json:uart_wait}}{fig:uart_wait}\newpage\noindent
Considering the design is created to send 10 bits (one start bit, 8 data bits and one stop bit) over its output line and every bit is held for 434 clock cycles, it would take a WaveDrom file of at least
\begin{equation}
	8 + 10 * 434 = 4348
\end{equation}
clock cycles to create this test. This would create immense WaveDrom files and would nullify the benefits of this whole approach. It is vital to create a simple and clear way to implement this test in WaveDrom. To do this, two new WaveDrom characters are used.
\subparagraph{The 'x' character} is part of the WaveDrom character set and signifies an unknown value. When this character is read by the conversion software it is processed just like any other character, except when it comes to checking output values. In the testbench, if an 'x' is encountered for a certain signal the normal check is simply skipped. In other words, an ‘x’ in the WaveDrom file means that this signal will not be checked at this point. Because this character only affects the checking of signals, it has to be used in output signals and can not be used elsewhere.

\subparagraph{The '\textbar' character} is also part of the WaveDrom character set and is used to indicate that for an undefined time a signal is not shown. The meaning of this character changes a little for this application. Here it can only be placed in clock signal and signifies that the simulation loops for a certain amount of clock periods. During this loop, the simulator will check whether the output signals remain unchanged. The amount of clock periods a simulation should loop has to be specified in the new loop\_times field as shown in the example above. Multiple loops can be added by adding new '\textbar' character and corresponding loop times, but, other than in an ordinary WaveDrom file, the wave value ('p' or 'n') has to be repeated after the loop character as seen in the next example.
\npar
Adding these two characters makes it possible to write the 4348 clock cycles long test in just 9, by adding a loop for $10*434 = 4340$ cycles. The downside, however, is that during this period the output can not change or is simply not checked.
\newpage
\subsection{Application example}
The following test shows the use of these features. In this example a designer wants to check whether the device can send two consecutive bytes, but is not interested in the sending itself, because that has been tested in another test.
\begin{lstlisting}[style=json, caption={Source file for creating third transmission test for the UART design in \ref{appendix:uart}}, label={json:uart_2_bytes}]
{"name": "uart_tx", "test" : "uart_send_2_bytes", 
"description": "Send two consecutive byte with a parallel to serial uart.", 
"signal": [
	["CLK",
		{"name": "clk", "wave": "n......|n......|", "type":"std_logic", "period": "2", "clock_period": "10", "loop_times" : ["10*434", "10*434"]}],
	["IN",
		{"name": "tvalid", "wave": "0.1..0............1..0..........", "type": "std_logic"},
		{"name" : "tdata", "wave": "=.=..=........x.==..=.........x.", "data": ["0", "249", "0", "0", "127", "0"], "type" : "std_logic_vector", "vector_size" : "8"}],
	["OUT",
		{"name": "tx", "wave": "1....0........x.1....0........x.", "type": "std_logic"},
		{"name": "tready", "wave": "01.0..........x.1..0..........x.", "type": "std_logic"}]
]}
\end{lstlisting}\noindent
\MijnFig{width=.9\textwidth}{images/uart_2_bytes}{Wave traces generated by WaveDrom from code \ref{json:uart_2_bytes}}{fig:uart_2_bytes}\nline
This relatively small file forms the base of a testbench that will run for over 8000 clock periods. The wave traces are also shown in appendix \ref{appendix:more_examples:uart} in more detail.
\section{Overview}
The full code can be found online \cite{github}. An overview of the code functionality is given in image \ref{fig:tb_creation_overview}. This overview corresponds to the purple collored section of figure \ref{fig:overview_color}%
\MijnFig{width=.76\textwidth}{images/tb_code_overview}{Overview of the testbench creation code}{fig:tb_creation_overview}\clearpage\noindent
The code is run for every WaveDrom file in the resource folder (see appendix \ref{user_guide}: user guide). The method used in this program can be compared to building a \mbox{prefabricated} house. First the walls, cellar, floors and roof are fabricated in the factory. These are elements a basic house needs (combinatorial testbenches). Some houses require special additions like a swimming pool or solar panels, however (timed testbenches, looping testbenches). These will be fabricated only if necessary. Afterwards all elements will be put together in accordance with the blueprint (template).
\npar
From the WaveDrom file all info is extracted and all elementary testbench building blocks are generated. These are the elements every testbench needs. They include signal declarations, uut declaration and uut port map. A full list can be found in §\ref{TD:vhdl_creation}. The testbench header is also created. This holds the test name and description and will be added to the testbench later as a comment.
\npar
At this point all the building blocks to create a combinatorial testbench (a basic house) are available, but timed testbenches require some additions, like a clock driving process and edge triggering. To check for a timed test it suffices to check whether there is a signal labeled "CLK". If there is no "CLK" label, the test will be combinatorial and the testbench can be assembled. Otherwise the additional building blocks must be generated before the testbench can be assembled. 
\npar
The building blocks available now are enough to build a timed testbench, but not testbenches that have time loops. If the "loop\_times" field is defined in the clock signal, it means that there are time loops in this test and the corresponding building block should be generated too.
\npar
When all building block are generated they are added to the template using keywords. These keywords can be considered the blueprint of the house. They assign a place to every building block. When every building block is placed at the right keyword the testbench has been completed and the file can be saved.\newpage
\section{Wave trace comparison}
Until now the focus has been primarily on creating testbenches from WaveDrom input files. However, this is only part of the solution. In a design validation process the simulation result (wave traces) has to be compared to the description in the designs documentation.
\npar
Because the testbenches are directly derived from the same files that generate the documentation wave traces, it is safe to assume that full specification compatibility can be checked inside the testbench. In other words: if a test passes the simulation, it can be regarded as compliant to that aspect of its specification. In the same way it is certain that the current design does not comply if the test fails. Testbenches that meet these requirements are considered self checking. If that is the case, it is important to clearly determine where the simulation fails in order to understand what caused the defect and eventually correct it.
\subsection{Ideal solution}\label{TD:ideal_solution}
As it is not desirable to stop a simulation when an error is encountered, errors should be logged during simulation and processed afterwards. As the simulation result and the documentation both consist of wave traces of the same signals, a simple and clear way to compare them would be to place each signal and their corresponding simulated signal side by side and place a marker to show every error that was logged during simulation. This principle is illustrated by the image below.
\MijnFig{width=\textwidth}{images/error_example}{Ideal error marking}{fig:error_example}\newpage\noindent
Every marker will be accompanied by a log message.
\begin{customenv}
	\label{log:example}
	\begin{itemize}
		\centering
		\item [error1:] unexpected output at clock tick 3, expected '1', got '0'.
	\end{itemize}
\end{customenv}\nline
At this point testbenches can be automatically generated by the software. In these testbenches every time step is numbered. This means that in the VHDL testbench there is an internal signal called 'n' that is incremented every internal clock cycle. Because the actual clock signal is driven on the rising and falling edge of the internal clock, there is a direct correspondence between 'n' and the x-th clock cycle in the wave trace file, where
\begin{equation}
	x = n/period
\end{equation}
and period is the relative clock period set by the "period" field in the WaveDrom file. In other words, n times the relative clock period gives a user the clock cycle on which an error occurred. The step number n is always displayed at the top in a simulation result.
\npar
To keep this correlation between wave trace file and simulation file we need to add one exception to the rule: n can only be incremented once during a time loop, because while a time loop can be hundreds of internal clock periods long, it is denoted as only one clock period in a wavedrom file.
\subsection{Practical approach}\label{TD:practical_approach}\label{log:error_message}
Comparing WaveDrom generated wave traces and simulation generated wave traces remains a cumbersome process. When an error occurs a user still has to manually find the corresponding time step in both the documentation wave traces and the simulation wave traces and compare those.
\npar
The ideal system proposed in \ref{TD:ideal_solution} could facilitate this process enormously. It would bundle the documentation wave traces and the simulation wave traces in one easy to comprehend wave trace file.
\npar
Because the documentation wave traces and the simulation wave traces are indirectly linked via the source file, it is possible to use the source file as a base for the result files and add the error messages logged during simulation to it. The VUnit Log package can log all error messages to a file. This log package is integrated into the VUnit Check package that offers conditional log messages, which is ideal for this application. The code below is an example check for the signal sig\_example. Because no specific checker is specified, the universal checker is automatically used.
\begin{lstlisting}[style=vhdl, caption={Signal checking in VHDL}, label={vhdl:checking}]
if sig_example_values(n) /= 'X' then
	check(sig_example = sig_example_values(n),  
	"This check failed. Expected example = " &
	std_logic'image(sig_example_values(n)) & ", 
	got example = " & std_logic'image(sig_example) & 
	" at n = " & integer'image(n) & ".");
end if;
\end{lstlisting}\noindent
If a signal is to be checked (the expected value is not 'X') the current value is compared to the expected value and an error report is generated when they are not equal. An example error report is shown in log message 2. The code below initialises the universal checker and is executed on testbench start.
\begin{lstlisting}[style=vhdl, caption={}, label={vhdl:checker_init}]
checker_init(warning, "", ".warning_log/test_name_messages.csv", level, verbose_csv, failure, ',', false);
\end{lstlisting}\noindent
The initialisation process defines an output file for the log message. This way the log message from the check in code \ref{vhdl:checking} is added to a .csv file in a hidden subfolder named ".warning\_log/" and contains the entity name of the testbench it is derived from.
An example message that could be logged to the file ".warning\_log/example\_messages.csv" by the example above is:
\begin{customenv}
	\label{log:error_message}
	\begin{itemize}
		\caption{Example error message}
		\centering
		\item [Warning:] "This check failed. Expected example = '0', \\
		got example = '1' at n = 4."
	\end{itemize}
\end{customenv}\nline
This directly links the actual error to a specific point in time. From the current system it is possible to derive the system proposed as the ideal solution in §\ref{TD:ideal_solution}.\newpage
\subsubsection{Look and feel}
The image below is a proposal for the layout of the comparison file based on a failing AND-gate test. More detail on this test can be found in §\ref{some_examples:andgate_failing}.
\MijnFig{width=\textwidth}{images/andgate_failing}{Layout proposal for result files}{fig:andgate_failing_result}\nline
This image shows the input wave traces of signals 'A' and 'B', the expected wave traces of signal 'F' and the simulated wave traces of signal 'F\_sim'. Every difference between expected and simulated signal wave traces is highlighted and labeled.
\npar
It is generated by a WaveDrom file very similar to the input file for this specific test software. This means that the input file can be easily manipulated by the software to create this image.
\npar
These changes include adding a title and an internal clock counter (equivalent to the 'n' signal in the simulation wave traces) in the header field, adding the simulation signal (F\_sim) to the file and adding nodes and edges to the signals.\newpage
\subsection{Preparations}
The image in the previous section was generated by the following WaveDrom file, while the original code for the failing AND-gate test can be found in §\ref{some_examples:andgate_failing}.
\begin{lstlisting}[style=json, caption={Source file for the proposed layout in fig \ref{fig:andgate_failing_result}}, label={json:andgate_failing_example}]
{"name": "andGate_timed", "test" : "andgate_failing", 
"description": "a full AND-gate test designed to fail",  "signal": [
	["CLK",
		{"name": "CLK", "wave": "p......", "type":"std_logic", "period":"2", "clock_period": "20"}],
	["IN",
		{"name": "A", "wave": "01010..", "type": "std_logic", "period":"2"},
		{"name": "B", "wave": "0.1.0.....1.0.", "type": "std_logic"}],
	["OUT",
		{"name": "F",     "wave": "0.....1.0.....", "type": "std_logic", "node": "..ac..eg"},
		{"name": "F_sim", "wave": "0.110.000.....", "type": "std_logic", "node": "..bd..fh"}]
], 
"head": {"text": ["tspan", {"class": "error h3"}, "Simulation failure "], "tick": 0}, 
"edge": ["a-b W1", "c-d W2", "e-f W3", "g-h W4"]
}
\end{lstlisting}\noindent
The failing AND-gate test will output the following messages:%
\begin{customenv}
	\caption{Failing andgate log messages}
	\begin{itemize}
		\centering
		\item [WARNING:] This check failed. Expected F = '0', got F = '1' at n = 2.
		\item [WARNING:] This check failed. Expected F = '0', got F = '1' at n = 3.
		\item [WARNING:] This check failed. Expected F = '1', got F = '0' at n = 6.
		\item [WARNING:] This check failed. Expected F = '1', got F = '0' at n = 7.
	\end{itemize}
\end{customenv}
\newpage\noindent
The original code serves as the base for the final comparison file. Additional information can be added based on the log messages above.
\npar
In a coding environment this is not an information format that is easy to work with, so another log file is created, which will hold the same information in a more processable format. To write to this new file, a new checker is added to every testbench. This is done by adding a new variable of type checker\_t to the template file (which will cause it to be added to every generated testbench) and initializing it similarly to the universal checker (see code \ref{vhdl:checker_init}).
\begin{lstlisting}[style=vhdl, caption={Custom checker declaration}, label={vhdl:new_checker_declaration}]
shared variable warning_logger : checker_t;
\end{lstlisting}\noindent
\begin{lstlisting}[style=vhdl, caption={Custom checker initialisation}, label={vhdl:new_checker_init}]
checker_init(warning_logger, warning, "", ".warning_log/test_name_logs.csv", level, verbose_csv, failure, ',', false);
\end{lstlisting}\noindent
Now a new conditional log can be added that will write to the new file. The full check code for an example signal is now:
\begin{lstlisting}[style=vhdl, caption={Improved signal checking}, label={vhdl:improved_check}]
if sig_example_values(n) /= 'X' then
	check(sig_example = sig_example_values(n), 
		integer'image(error_number) & "original message"); -- original message is logged here
	check(warning_logger, sig_example = sig_example_values(n), 
		integer'image(error_number) & "new log message", line_num => error_number); -- new log message is logged here
	if sig_example /= sig_example_values(n) then
		error_number := error_number +1;
	end if;
end if;
\end{lstlisting}\noindent
Where the universal checker is used to conditionally log the original message and the new warning\_logger checker is used to log the new message to another file. To link the original messages to the new logs, an error number is added to both logs, which is incremented every time an error occurs.
\newpage\noindent
The new warning logs are made following this pattern:%
\begin{customenv}
%	\caption{}
	\begin{itemize}
		\centering
		\item [] [“warning no”, “signal involved”,”expected value”, “actual value”, “n”] 
	\end{itemize}
\end{customenv}\nline
The full output after running the failing AND-gate example will now be:
\begin{customenv}
	\caption{Log messages in the "andgate\_failing\_message.csv" file}
	\begin{itemize}
		\centering
		\item [WARNING: 1.] This check failed. Expected F = '0', got F = '1' at n = 2.
		\item [WARNING: 2.] This check failed. Expected F = '0', got F = '1' at n = 3.
		\item [WARNING: 3.] This check failed. Expected F = '1', got F = '0' at n = 6.
		\item [WARNING: 4.] This check failed. Expected F = '1', got F = '0' at n = 7.
	\end{itemize}
\end{customenv}
\begin{customenv}
	\caption{Log messages in the "andgate\_failing\_log.csv" file}
	\begin{itemize}
		\centering
		\item [] ["1", "F", "0", "1", "2"]
		\item [] ["2", "F", "0", "1", "3"]
		\item [] ["3", "F", "1", "0", "6"]
		\item [] ["4", "F", "1", "0", "7"]
	\end{itemize}
\end{customenv}\nline
Now all information can be easily imported and processed. The software can read both the WaveDrom JSON file and the logged information, modify the JSON content and write it to an output file.
\newpage\noindent
\subsection{WaveDrom result file}
As stated in §\ref{TD:practical_approach} the result file can be generated from the original input file and the warning logs (the "test\_name.json" and the "test\_name\_result.csv" in the relative directory “sresult”). The flow diagram below shows the function of the software that generates the compare files. This image corresponds to the green part of figure \ref{fig:overview_color}. \MijnFig{width=.88\textwidth}{images/wave_trace_analysis_overview}{Overview of the wave trace analysis code}{fig:wavetrace_analysis_overview}\newpage\noindent
After reading the input files, the software checks whether or not there are messages logged. If there are no logged messages, the simulation succeeded. In this case there is nothing else to be done than to add a header and create the output file. In case there are messages logged,  however, the simulation failed and the process becomes more complicated.A corresponding header is added containing a title and the time step counter. Then all messages are read one by one and further processed.
\npar
Consider the WaveDrom input file and the output messages from the failing AND-gate example:
\begin{lstlisting}[style=json, caption={Source file for a failing AND-gate example}, label={json:andgate_failing}]
{"name": "andGate_timed", "test" : "andgate_failing", 
"description": "a full AND-gate test designed to fail", 
"signal": [
	["CLK",
		{"name": "CLK", "wave": "p......", "type":"std_logic", "period":"2"}],
	["IN",
		{"name": "A", "wave": "0.1.0.1.0.....", "type": "std_logic"},
		{"name": "B", "wave": "0.1.0.....1.0.", "type": "std_logic"}],
	["OUT",
		{"name": "F", "wave": "0.....1.0.....", "type": "std_logic"}]
]}
\end{lstlisting}\noindent
\begin{customenv}
	\caption{Log messages in the "andgate\_failing\_result.csv" file}
	\begin{itemize}
		\centering
		\item [] ["1", "F", "0", "1", "2"]
		\item [] ["2", "F", "0", "1", "3"]
		\item [] ["3", "F", "1", "0", "6"]
		\item [] ["4", "F", "1", "0", "7"]
	\end{itemize}
\end{customenv}\newpage\noindent
Each message alters the output file in several ways. Consider the first message for example. When the software reads a new message, it first converts the message to a readable list and then determines the name of the signal involved, which is 'F'. It then finds that signal in the current WaveDrom file and copies it. This copy is renamed to 'F\_sim'. The wave traces for this signal are exactly equal to the wave traces of 'F', which means that it holds the same errors. These errors are fixed by replacing the wave value at time step 'n', given in the last field by the 'expected value' in the second to last field. The 'F\_sim' signal is now added to the output data. 
\npar
Then, for both the 'F' and 'F\_sim' signal, the "node" field is added. This field adds a name to a specific time step in a signal. This is necessary to enable the next step. The node field for the ‘F’ and 'F\_sim' signals would be:
\begin{lstlisting}[style=json]
	"node": "..a"
	"node": "..b"
\end{lstlisting}\noindent
respectively. This way, for both signals, the third time step (time steps are numbered starting from 0) has a name. A named time step is also called a node.
\npar
Finally, a line, called an edge, is added to connect both nodes. This is done by appending an edge field to the WaveDrom file.
\begin{lstlisting}[style=json]
"edge":["a-b W1"]
\end{lstlisting}\noindent
This way an edge labeled 'W1' connecting node a to b will be created. This label is derived from the error number in the first field of the log message.
\npar
Lastly, all signals involved ('F' and 'F\_sim') will be marked red.
\newpage\noindent
The JSON data imported from the source file will now look like this:
\begin{lstlisting}[style=json, caption={Temporary content of the result file of a failing AND-gate example}, label={json:andgate_failing_part}]
{"name": "andGate_timed", "test" : "andgate_full", "description": "Test all possible inputs for an AND-gate", "signal": [
	["CLK",
		{"name": "CLK", "wave": "p......", "type":"std_logic", "period":"2", "clock_period": "20"}],
	["IN",
		{"name": "A", "wave": "01010..", "type": "std_logic", "period":"2"},
		{"name": "B", "wave": "0.1.0.....1.0.", "type": "std_logic"}],
	["OUT",
		{"name": "F",     "wave": "0.....1.0.....", "type": "std_logic", "node": "..a"},
		{"name": "F_sim", "wave": "0.1.0.........", "type": "std_logic", "node": "..b"}]
], "head": {"text": ["tspan", {"class": "error h3"}, "Simulation failure "], "tick": 0}, 
"edge": ["a-b W1"]
}
\end{lstlisting}\noindent
Which yields:
\MijnFig{width=\textwidth}{images/andgate_failing_part}{Wave traces generated by WaveDrom from code \ref{json:andgate_failing_part}}{fig:andgate_failing_part}\nline
After this, the second message is read and processed the same way. The only difference is that 'F\_sim' already exists. In this case the 'F\_sim' signal is altered rather than created and the node field is extended.
\npar
When all four messages are processed the JSON data is written to a file in the  ouput folder. The file is shown in code \ref{json:andgate_failing_result}.
\begin{lstlisting}[style=json, caption={Final content of the result file of a failing AND-gate example}, label={json:andgate_failing_result}]
{"name": "andGate_timed", "test" : "andgate_failing", 
"description": "a full AND-gate test designed to fail",
"signal": [
	["CLK",
		{"name": "CLK", "wave": "p......", "type":"std_logic", "period":"2", "clock_period": "20"}],
	["IN",
		{"name": "A", "wave": "01010..", "type": "std_logic", "period":"2"},
		{"name": "B", "wave": "0.1.0.....1.0.", "type": "std_logic"}]
	,["OUT",
		{"name": "F",     "wave": "0.....1.0.....", "type": "std_logic", "node": "..ac..eg"},
		{"name": "F_sim", "wave": "0.110.000.....", "type": "std_logic", "node": "..bd..fh"}]
	], 
"head": {"text": ["tspan", {"class": "error h3"}, "Simulation failure "], "tick": 0}, 
"edge": ["a-b W1", "c-d W2", "e-f W3", "g-h W4"]
}
\end{lstlisting}\noindent
This yields figure \ref{fig:andgate_failing_result2}.
\MijnFig{width=\textwidth}{images/andgate_failing}{Wave traces generated by WaveDrom from code \ref{json:andgate_failing_result}}{fig:andgate_failing_result2}\nline
Which is exactly the same as the goal image in figure \ref{fig:andgate_failing_result}.\newpage

